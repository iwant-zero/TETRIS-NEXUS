<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>TETRIS NEXUS - FINAL</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap');
        body { background: #05050a; color: #00f2ff; font-family: 'Orbitron', sans-serif; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; overflow: hidden; }
        #wrapper { position: relative; border: 2px solid #00f2ff; padding: 20px; background: rgba(0,0,0,0.8); box-shadow: 0 0 20px #00f2ff; display: flex; gap: 20px; }
        #board { width: 250px; height: 500px; background: #000; position: relative; border: 1px solid #333; }
        .block { position: absolute; width: 25px; height: 25px; box-sizing: border-box; border: 1px solid rgba(255,255,255,0.2); }
        .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 100; }
        .btn { background: none; border: 2px solid #00f2ff; color: #00f2ff; padding: 15px 30px; font-family: 'Orbitron'; font-size: 20px; cursor: pointer; transition: 0.3s; }
        .btn:hover { background: #00f2ff; color: #000; box-shadow: 0 0 20px #00f2ff; }
        .hidden { display: none !important; }
        /* 블록 색상 */
        .I { background: #00f0f0; box-shadow: 0 0 10px #00f0f0; }
        .J { background: #0000f0; box-shadow: 0 0 10px #0000f0; }
        .L { background: #f0a000; box-shadow: 0 0 10px #f0a000; }
        .O { background: #f0f000; box-shadow: 0 0 10px #f0f000; }
        .S { background: #00f000; box-shadow: 0 0 10px #00f000; }
        .T { background: #a000f0; box-shadow: 0 0 10px #a000f0; }
        .Z { background: #f00000; box-shadow: 0 0 10px #f00000; }
    </style>
</head>
<body>

<div id="wrapper">
    <div id="board"></div>
    <div style="width: 100px; text-align: center;">
        <p style="font-size: 12px;">SCORE</p>
        <p id="score" style="font-size: 20px;">0</p>
    </div>

    <div id="start-screen" class="overlay">
        <h1 style="margin-bottom: 30px;">NEXUS</h1>
        <button id="start-btn" class="btn">START GAME</button>
    </div>

    <div id="game-over" class="overlay hidden">
        <h2 style="color: red;">GAME OVER</h2>
        <button id="retry-btn" class="btn">RETRY</button>
    </div>
</div>

<script>
    // 모든 요소가 로드된 후 실행되도록 보장
    window.onload = function() {
        const boardEl = document.getElementById('board');
        const scoreEl = document.getElementById('score');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over');
        const startBtn = document.getElementById('start-btn');
        const retryBtn = document.getElementById('retry-btn');

        const ROWS = 20;
        const COLS = 10;
        let grid, score, currentPiece, gameInterval;

        const SHAPES = {
            I: [[1, 1, 1, 1]],
            J: [[1, 0, 0], [1, 1, 1]],
            L: [[0, 0, 1], [1, 1, 1]],
            O: [[1, 1], [1, 1]],
            S: [[0, 1, 1], [1, 1, 0]],
            T: [[0, 1, 0], [1, 1, 1]],
            Z: [[1, 1, 0], [0, 1, 1]]
        };

        function init() {
            grid = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
            score = 0;
            scoreEl.innerText = score;
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            currentPiece = createPiece();
            if (gameInterval) clearInterval(gameInterval);
            gameInterval = setInterval(() => move(0, 1), 800);
            draw();
        }

        function createPiece() {
            const keys = Object.keys(SHAPES);
            const type = keys[Math.floor(Math.random() * keys.length)];
            return { type, shape: SHAPES[type], x: 3, y: 0 };
        }

        function draw() {
            boardEl.innerHTML = '';
            grid.forEach((row, y) => {
                row.forEach((type, x) => {
                    if (type) addBlock(x, y, type);
                });
            });
            if (currentPiece) {
                currentPiece.shape.forEach((row, dy) => {
                    row.forEach((v, dx) => {
                        if (v) addBlock(currentPiece.x + dx, currentPiece.y + dy, currentPiece.type);
                    });
                });
            }
        }

        function addBlock(x, y, type) {
            const b = document.createElement('div');
            b.className = 'block ' + type;
            b.style.left = x * 25 + 'px';
            b.style.top = y * 25 + 'px';
            boardEl.appendChild(b);
        }

        function move(dx, dy) {
            if (!collision(dx, dy)) {
                currentPiece.x += dx;
                currentPiece.y += dy;
                draw();
                return true;
            } else if (dy > 0) {
                lock();
                currentPiece = createPiece();
                if (collision(0, 0)) {
                    clearInterval(gameInterval);
                    gameOverScreen.classList.remove('hidden');
                }
            }
            return false;
        }

        function collision(dx, dy) {
            return currentPiece.shape.some((row, py) => {
                return row.some((v, px) => {
                    let nx = currentPiece.x + px + dx;
                    let ny = currentPiece.y + py + dy;
                    return v && (nx < 0 || nx >= COLS || ny >= ROWS || (ny >= 0 && grid[ny][nx]));
                });
            });
        }

        function lock() {
            currentPiece.shape.forEach((row, py) => {
                row.forEach((v, dx) => {
                    if (v) grid[currentPiece.y + py][currentPiece.x + dx] = currentPiece.type;
                });
            });
            clearLines();
        }

        function clearLines() {
            grid = grid.filter(row => !row.every(cell => cell !== 0));
            while (grid.length < ROWS) grid.unshift(Array(COLS).fill(0));
            score += 100;
            scoreEl.innerText = score;
        }

        function rotate() {
            const r = currentPiece.shape[0].map((_, i) => currentPiece.shape.map(row => row[i]).reverse());
            if (!collision(0, 0, r)) {
                currentPiece.shape = r;
                draw();
            }
        }

        // 버튼 클릭 이벤트 바인딩
        startBtn.onclick = init;
        retryBtn.onclick = init;

        window.onkeydown = e => {
            if (e.key === 'ArrowLeft') move(-1, 0);
            if (e.key === 'ArrowRight') move(1, 0);
            if (e.key === 'ArrowDown') move(0, 1);
            if (e.key === 'ArrowUp') rotate();
        };
    };
</script>
</body>
</html>
